<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Pose Strict Horizon</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Pretendard', sans-serif;
        }
        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        video, canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        /* ì „ë©´ ì¹´ë©”ë¼ëŠ” ê±°ìš¸ëª¨ë“œ */
        .mirror { transform: scaleX(-1); }
        .normal { transform: scaleX(1); }
        
        video { z-index: 1; }
        canvas { z-index: 2; }

        /* ìƒíƒœ ë©”ì‹œì§€ UI */
        #status-box {
            position: absolute;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3;
            width: 90%;
            text-align: center;
            pointer-events: none; /* í„°ì¹˜ ë°©í•´ ì•ˆí•¨ */
        }
        #message {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 16px;
            font-size: 1.2rem;
            font-weight: 800;
            border: 4px solid #FF0000; /* ê¸°ë³¸ ë¹¨ê°• */
            box-shadow: 0 4px 15px rgba(0,0,0,0.6);
            transition: all 0.2s ease;
        }
        #debug {
            margin-top: 8px;
            font-size: 0.85rem;
            color: #eee;
            background-color: rgba(0,0,0,0.4);
            padding: 5px 10px;
            border-radius: 8px;
            display: inline-block;
        }

        /* ì¹´ë©”ë¼ ì „í™˜ ë²„íŠ¼ */
        #switch-btn {
            position: absolute;
            bottom: 40px;
            right: 30px;
            z-index: 4;
            background-color: white;
            border: none;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.4);
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.1s;
        }
        #switch-btn:active { transform: scale(0.9); }
    </style>
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
</head>
<body>
    <div class="container">
        <video id="input_video" class="mirror" playsinline autoplay muted></video>
        <canvas id="output_canvas" class="mirror"></canvas>
        
        <div id="status-box">
            <div id="message">ë¡œë”©ì¤‘...</div>
            <div id="debug"></div>
        </div>

        <button id="switch-btn">ğŸ”„</button>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const messageDiv = document.getElementById('message');
        const debugDiv = document.getElementById('debug');
        const switchBtn = document.getElementById('switch-btn');

        let isFrontCamera = true;
        let currentStream = null;
        let pose = null;

        // ì¢Œí‘œ ë³€í™˜
        function toPixel(landmark, width, height) {
            return { x: landmark.x * width, y: landmark.y * height };
        }

        // 1. ê´€ì ˆ ê°ë„ (êº¾ì„) ê³„ì‚° (0~180ë„)
        function calculateAngle(a, b, c) {
            const radians = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x);
            let angle = Math.abs(radians * 180.0 / Math.PI);
            if (angle > 180.0) angle = 360 - angle;
            return angle;
        }

        // 2. ìˆ˜ì§ í¸ì°¨ (Yì¶• ê¸°ì¤€) - ëª¸ì´ ì–¼ë§ˆë‚˜ ê¸°ìš¸ì—ˆë‚˜
        function calculateVerticalDeviation(a, b) {
            const dx = Math.abs(b.x - a.x);
            const dy = Math.abs(b.y - a.y);
            const radians = Math.atan2(dx, dy); 
            return radians * 180.0 / Math.PI;
        }

        // 3. ìˆ˜í‰ í¸ì°¨ (Xì¶• ê¸°ì¤€) - íŒ”ì´ ì–¼ë§ˆë‚˜ ìˆ˜í‰(ã…¡ì)ì¸ê°€
        // ì–´ê¹¨ì—ì„œ ì†ëª©ìœ¼ë¡œ ì´ì–´ì§€ëŠ” ì„ ì˜ ê°ë„ë¥¼ ì½ë‹ˆë‹¤.
        function calculateHorizontalDeviation(a, b) {
            // atan2(dy, dx) -> 0ë„ë‚˜ 180ë„ê°€ ìˆ˜í‰
            const dy = b.y - a.y;
            const dx = b.x - a.x;
            let angle = Math.atan2(dy, dx) * 180.0 / Math.PI;
            // -180 ~ 180 ë²”ìœ„ë¥¼ 0 ~ 180 ì ˆëŒ“ê°’ìœ¼ë¡œ ë³€í™˜ (ìˆ˜í‰ í¸ì°¨ë§Œ ë³´ê¸° ìœ„í•¨)
            // 0ë„ ê·¼ì²˜ë©´ ì˜¤ë¥¸ìª½ ìˆ˜í‰, 180ë„(-180ë„) ê·¼ì²˜ë©´ ì™¼ìª½ ìˆ˜í‰
            angle = Math.abs(angle); 
            
            // 180ë„ ê·¼ì²˜(ì™¼ìª½ íŒ”)ì¼ ê²½ìš° 0ë„ ê¸°ì¤€ìœ¼ë¡œ ë³´ì •
            if (angle > 90) {
                angle = Math.abs(180 - angle);
            }
            return angle; // 0ì— ê°€ê¹Œìš¸ìˆ˜ë¡ ì™„ë²½í•œ ìˆ˜í‰
        }

        function onResults(results) {
            const width = videoElement.videoWidth;
            const height = videoElement.videoHeight;
            canvasElement.width = width;
            canvasElement.height = height;

            canvasCtx.save();
            canvasCtx.clearRect(0, 0, width, height);

            if (results.poseLandmarks) {
                const rawLm = results.poseLandmarks;
                const p = {};
                [11,12,13,14,15,16,23,24,25,26,27,28].forEach(idx => {
                    if(rawLm[idx]) p[idx] = toPixel(rawLm[idx], width, height);
                });

                // === ğŸ”¥ [ì—„ê²©í•œ ê¸°ì¤€ ì„¤ì •] ğŸ”¥ ===
                const BODY_TILT_LIMIT = 5;      // ëª¸ ê¸°ìš¸ê¸° 5ë„ ì´ë‚´ (ë§¤ìš° ì—„ê²©)
                const ARM_HORIZON_LIMIT = 15;   // íŒ” ìˆ˜í‰ ì˜¤ì°¨ 15ë„ ì´ë‚´ (ã…¡ì ëª¨ì–‘)
                const ELBOW_STRAIGHT_MIN = 165; // íŒ”ê¿ˆì¹˜ í´ì§ ê°ë„ (165ë„ ì´ìƒ)
                const KNEE_STRAIGHT_MIN = 170;  // ë¬´ë¦ í´ì§ ê°ë„

                let isBodyReady = false;
                let isArmReady = false;
                let debugMsg = "ì „ì‹ ì´ ë‚˜ì˜¤ê²Œ ì„œì£¼ì„¸ìš”";
                let failReason = "";

                if(p[11] && p[23] && p[27] && p[12] && p[24] && p[28]) {
                    // 1. ëª¸ ìˆ˜ì§ ê²€ì‚¬ (ì™¼ìª½/ì˜¤ë¥¸ìª½ ì¤‘ ë” ë˜‘ë°”ë¥¸ ìª½ ê¸°ì¤€)
                    const lTorso = calculateVerticalDeviation(p[11], p[23]);
                    const lLeg = calculateVerticalDeviation(p[23], p[27]);
                    const lKnee = calculateAngle(p[23], p[25], p[27]);
                    
                    const rTorso = calculateVerticalDeviation(p[12], p[24]);
                    const rLeg = calculateVerticalDeviation(p[24], p[28]);
                    const rKnee = calculateAngle(p[24], p[26], p[28]);

                    // ì™¼ìª½ ëª¸ì´ ìˆ˜ì§ì¸ê°€?
                    const leftBodyOk = (lTorso < BODY_TILT_LIMIT) && (lLeg < BODY_TILT_LIMIT) && (lKnee > KNEE_STRAIGHT_MIN);
                    // ì˜¤ë¥¸ìª½ ëª¸ì´ ìˆ˜ì§ì¸ê°€?
                    const rightBodyOk = (rTorso < BODY_TILT_LIMIT) && (rLeg < BODY_TILT_LIMIT) && (rKnee > KNEE_STRAIGHT_MIN);

                    isBodyReady = leftBodyOk || rightBodyOk;
                    const curBodyTilt = Math.round(Math.min(lTorso, rTorso));

                    // 2. íŒ” ìˆ˜í‰(ã…¡ì) ê²€ì‚¬
                    // A. íŒ”ê¿ˆì¹˜ê°€ í´ì ¸ì•¼ í•¨
                    const lElbow = calculateAngle(p[11], p[13], p[15]);
                    const rElbow = calculateAngle(p[12], p[14], p[16]);
                    
                    // B. ì–´ê¹¨-ì†ëª© ì„ ì´ ìˆ˜í‰ì´ì–´ì•¼ í•¨
                    const lHorizon = calculateHorizontalDeviation(p[11], p[15]);
                    const rHorizon = calculateHorizontalDeviation(p[12], p[16]);

                    // ì™¼ìª½ íŒ”ì´ ì¡°ê±´ ë§Œì¡±? (í´ì§ + ìˆ˜í‰)
                    const leftArmOk = (lElbow > ELBOW_STRAIGHT_MIN) && (lHorizon < ARM_HORIZON_LIMIT);
                    // ì˜¤ë¥¸ìª½ íŒ”ì´ ì¡°ê±´ ë§Œì¡±?
                    const rightArmOk = (rElbow > ELBOW_STRAIGHT_MIN) && (rHorizon < ARM_HORIZON_LIMIT);

                    isArmReady = leftArmOk || rightArmOk;
                    const curArmHorizon = Math.round(Math.min(lHorizon, rHorizon)); // ê°€ì¥ ìˆ˜í‰ì— ê°€ê¹Œìš´ ê°’

                    // === [ìƒíƒœ ë©”ì‹œì§€ ê²°ì •] ===
                    if (!isBodyReady) {
                        failReason = "ëª¸ì´ ê¸°ìš¸ì—ˆìŠµë‹ˆë‹¤";
                        debugMsg = `ëª¸ ê¸°ìš¸ê¸°: ${curBodyTilt}Â° (ëª©í‘œ: 5Â°ì´ë‚´)`;
                    } else if (!isArmReady) {
                        // ëª¸ì€ ëëŠ”ë° íŒ”ì´ ë¬¸ì œì¸ ê²½ìš°
                        if ((lElbow < ELBOW_STRAIGHT_MIN) && (rElbow < ELBOW_STRAIGHT_MIN)) {
                             failReason = "íŒ”ê¿ˆì¹˜ë¥¼ í´ì„¸ìš”";
                             debugMsg = "íŒ”ì´ êµ½ì—ˆìŠµë‹ˆë‹¤";
                        } else {
                             failReason = "íŒ”ì„ ìˆ˜í‰(ã…¡ì)ìœ¼ë¡œ ë“œì„¸ìš”";
                             debugMsg = `ìˆ˜í‰ ì˜¤ì°¨: ${curArmHorizon}Â° (ëª©í‘œ: ${ARM_HORIZON_LIMIT}Â°ì´ë‚´)`;
                        }
                    } else {
                        debugMsg = "ì™„ë²½í•©ë‹ˆë‹¤!";
                    }
                }

                // === [ìµœì¢… íŒì •: AND ì¡°ê±´] ===
                const isSuccess = isBodyReady && isArmReady;
                
                let color = "#FF0000"; // ê¸°ë³¸ ë¹¨ê°•

                if (isSuccess) {
                    color = "#00FF00"; // ì„±ê³µ ì´ˆë¡
                    messageDiv.innerText = "ì„±ê³µ! ì™„ë²½í•œ ìì„¸ì…ë‹ˆë‹¤";
                    messageDiv.style.borderColor = "#00FF00";
                    messageDiv.style.color = "#00FF00";
                } else {
                    messageDiv.innerText = failReason || "ìì„¸ë¥¼ ì·¨í•´ì£¼ì„¸ìš”";
                    messageDiv.style.borderColor = "#FF0000";
                    messageDiv.style.color = "#FFFFFF";
                }
                debugDiv.innerText = debugMsg;

                // ìŠ¤ì¼ˆë ˆí†¤ ê·¸ë¦¬ê¸°
                drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS, {color: color, lineWidth: 4});
                drawLandmarks(canvasCtx, results.poseLandmarks, {color: color, lineWidth: 2, radius: 4});
            }
            canvasCtx.restore();
        }

        async function setupCamera() {
            if (currentStream) currentStream.getTracks().forEach(track => track.stop());
            const constraints = {
                video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: isFrontCamera ? 'user' : 'environment' },
                audio: false
            };
            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                currentStream = stream;
                videoElement.srcObject = stream;
                if (isFrontCamera) { videoElement.className = 'mirror'; canvasElement.className = 'mirror'; } 
                else { videoElement.className = 'normal'; canvasElement.className = 'normal'; }
                return new Promise((resolve) => { videoElement.onloadedmetadata = () => { resolve(videoElement); }; });
            } catch (err) { alert("ì¹´ë©”ë¼ ì˜¤ë¥˜: " + err.message); }
        }

        async function renderFrame() {
            if (!videoElement.paused && !videoElement.ended) { await pose.send({image: videoElement}); }
            requestAnimationFrame(renderFrame);
        }

        async function main() {
            messageDiv.innerText = "ëª¨ë¸ ë¡œë”©ì¤‘...";
            pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
            pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, enableSegmentation: false, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            pose.onResults(onResults);
            await setupCamera();
            videoElement.play();
            renderFrame();
            messageDiv.innerText = "ì „ì‹ ì´ ë‚˜ì˜¤ê²Œ ì„œì£¼ì„¸ìš”";
        }

        switchBtn.addEventListener('click', async () => {
            isFrontCamera = !isFrontCamera;
            switchBtn.innerText = "â³";
            await setupCamera();
            videoElement.play();
            switchBtn.innerText = "ğŸ”„";
        });

        main();
    </script>
</body>
</html>
