<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Pose Detection v3 (Fix)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        video {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            z-index: 1;
        }
        canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            z-index: 2;
        }
        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 3;
            color: white;
            font-size: 1rem;
            background: rgba(0,0,0,0.6);
            padding: 15px;
            border-radius: 10px;
            white-space: pre-wrap;
            font-family: sans-serif;
            font-weight: bold;
        }
    </style>
    <!-- MediaPipe 라이브러리 -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
</head>
<body>
    <div class="container">
        <video id="input_video" playsinline></video>
        <canvas id="output_canvas"></canvas>
        <div id="status">로딩중...</div>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const statusDiv = document.getElementById('status');

        // [중요] 좌표를 픽셀 단위로 변환하는 함수
        // MediaPipe는 0~1 사이의 값을 주는데, 모바일 화면 비율(세로가 김)을 반영해야 각도가 정확함
        function toPixel(landmark, width, height) {
            return { x: landmark.x * width, y: landmark.y * height };
        }

        // 1. 세 점 사이의 각도 계산 (픽셀 좌표 기준)
        function calculateAngle(a, b, c) {
            const radians = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x);
            let angle = Math.abs(radians * 180.0 / Math.PI);
            if (angle > 180.0) angle = 360 - angle;
            return angle;
        }

        // 2. 수직 편차 계산 (Y축 기준)
        function calculateVerticalDeviation(a, b) {
            // X축의 차이가 적을수록 수직에 가까움
            const dx = Math.abs(b.x - a.x);
            const dy = Math.abs(b.y - a.y);
            
            // 아크탄젠트로 각도 구하기 (0도에 가까울수록 수직)
            const radians = Math.atan2(dx, dy); 
            return radians * 180.0 / Math.PI;
        }

        function onResults(results) {
            // 화면 크기 가져오기
            const width = videoElement.videoWidth;
            const height = videoElement.videoHeight;
            
            canvasElement.width = width;
            canvasElement.height = height;

            canvasCtx.save();
            canvasCtx.clearRect(0, 0, width, height);

            if (results.poseLandmarks) {
                const rawLm = results.poseLandmarks;
                
                // 모든 좌표를 픽셀 단위로 변환 (중요!)
                // 11:왼어깨, 12:오른어깨, 13:왼팔꿈치, 14:오른팔꿈치, 15:왼손목, 16:오른손목
                // 23:왼엉덩, 24:오른엉덩, 25:왼무릎, 26:오른무릎, 27:왼발목, 28:오른발목
                const p = {};
                [11,12,13,14,15,16,23,24,25,26,27,28].forEach(index => {
                    p[index] = toPixel(rawLm[index], width, height);
                });

                // --- [설정값] 이 값을 조절하여 난이도 변경 가능 ---
                const STRAIGHT_THRESHOLD = 165; // 팔, 다리가 펴졌다고 판단하는 각도 (클수록 엄격)
                const VERTICAL_THRESHOLD = 10;  // 수직에서 벗어나도 되는 허용 오차 (작을수록 엄격)

                // 1. 팔 펴짐 확인
                const leftArmAngle = calculateAngle(p[11], p[13], p[15]);
                const rightArmAngle = calculateAngle(p[12], p[14], p[16]);
                const isLeftArmStraight = leftArmAngle > STRAIGHT_THRESHOLD;
                const isRightArmStraight = rightArmAngle > STRAIGHT_THRESHOLD;

                // 2. 몸 수직 확인 (어깨-엉덩이 수직 AND 엉덩이-발목 수직 AND 무릎 펴짐)
                
                // 왼쪽
                const leftTorsoDev = calculateVerticalDeviation(p[11], p[23]);
                const leftLegDev = calculateVerticalDeviation(p[23], p[27]);
                const leftKneeAngle = calculateAngle(p[23], p[25], p[27]);
                // 몸통과 다리가 모두 수직 범위 내(10도)이고 무릎이 펴져야 함
                const isLeftBodyVertical = (leftTorsoDev < VERTICAL_THRESHOLD) && 
                                           (leftLegDev < VERTICAL_THRESHOLD) && 
                                           (leftKneeAngle > STRAIGHT_THRESHOLD);

                // 오른쪽
                const rightTorsoDev = calculateVerticalDeviation(p[12], p[24]);
                const rightLegDev = calculateVerticalDeviation(p[24], p[28]);
                const rightKneeAngle = calculateAngle(p[24], p[26], p[28]);
                const isRightBodyVertical = (rightTorsoDev < VERTICAL_THRESHOLD) && 
                                            (rightLegDev < VERTICAL_THRESHOLD) && 
                                            (rightKneeAngle > STRAIGHT_THRESHOLD);


                // --- [판단 및 상태 표시] ---
                let color = '#FF0000'; // 기본 빨강
                let statusText = "자세를 취해주세요";
                let debugText = []; // 디버깅용 메시지

                let success = false;

                // 조건 1: 몸이 1자 (수직)
                if (isLeftBodyVertical || isRightBodyVertical) {
                    success = true;
                    statusText = "성공: 몸이 수직입니다!";
                    debugText.push("몸 수직 감지됨");
                }

                // 조건 2: 팔이 1자 (수평이든 수직이든 쭉 펴짐)
                if (isLeftArmStraight || isRightArmStraight) {
                    // 이미 몸 때문에 성공했더라도 메시지 추가
                    if(success) {
                        statusText = "성공: 몸과 팔이 완벽합니다!";
                    } else {
                        success = true;
                        statusText = "성공: 팔을 폈습니다!";
                    }
                    if(isLeftArmStraight) debugText.push(`왼팔 펴짐(${Math.round(leftArmAngle)}°)`);
                    if(isRightArmStraight) debugText.push(`오른팔 펴짐(${Math.round(rightArmAngle)}°)`);
                }

                if (success) {
                    color = '#00FF00'; // 초록
                } else {
                    // 실패 시 원인 분석 (디버깅용)
                    if(leftArmAngle > 150) debugText.push(`왼팔 조금 굽음(${Math.round(leftArmAngle)}°)`);
                    if(leftTorsoDev < 30) debugText.push(`몸 기울기(${Math.round(leftTorsoDev)}°)`);
                }

                statusDiv.innerHTML = `<span style="font-size:1.2em">${statusText}</span><br><br><span style="font-size:0.8em; opacity:0.8">${debugText.join('\n')}</span>`;
                statusDiv.style.color = color;

                // 스켈레톤 그리기
                drawConnectors(canvasCtx, results.poseLandmarks, POSE_CONNECTIONS,
                             {color: color, lineWidth: 4});
                drawLandmarks(canvasCtx, results.poseLandmarks,
                            {color: color, lineWidth: 2, radius: 4});
            }
            canvasCtx.restore();
        }

        const pose = new Pose({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
        }});

        pose.setOptions({
            modelComplexity: 1,
            smoothLandmarks: true,
            enableSegmentation: false,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        pose.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await pose.send({image: videoElement});
            },
            width: 1280, // 입력 해상도
            height: 720
        });

        camera.start().then(() => {
            statusDiv.innerText = "카메라 시작됨";
        });
    </script>
</body>
</html>
