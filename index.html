<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Elbow Angle Sound</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Courier New', Courier, monospace;
        }
        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        video, canvas {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .mirror { transform: scaleX(-1); }
        .normal { transform: scaleX(1); }
        
        video { z-index: 1; }
        canvas { z-index: 2; }

        /* UI ìŠ¤íƒ€ì¼ */
        #status-box {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3;
            width: 90%;
            text-align: center;
            pointer-events: none;
        }
        #message {
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border: 2px solid #FF0000;
            font-size: 1.2rem;
            font-weight: bold;
            text-transform: uppercase;
        }
        #debug {
            margin-top: 5px;
            font-size: 0.9rem;
            color: #00FF00;
            background: rgba(0,0,0,0.7);
            display: inline-block;
            padding: 5px 10px;
        }

        #switch-btn {
            position: absolute;
            bottom: 30px;
            right: 20px;
            z-index: 4;
            background-color: #333;
            color: white;
            border: 2px solid white;
            padding: 15px 20px;
            font-family: inherit;
            font-weight: bold;
            font-size: 1rem;
            cursor: pointer;
        }

        #start-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 10;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            cursor: pointer;
        }
        #start-btn {
            border: 2px solid #00FF00;
            padding: 20px;
            margin-top: 20px;
            font-size: 1.5rem;
            color: #00FF00;
        }
    </style>
    <!-- MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
</head>
<body>
    <div class="container">
        <video id="input_video" class="mirror" playsinline autoplay muted></video>
        <canvas id="output_canvas" class="mirror"></canvas>
        
        <div id="status-box">
            <div id="message">WAITING...</div>
            <div id="debug"></div>
        </div>

        <button id="switch-btn">CAM SWITCH</button>

        <div id="start-overlay">
            <div style="text-align:center">UPLOAD 'pulling.mp3' & 'success.mp3'<br>BEFORE START</div>
            <div id="start-btn">TOUCH TO START</div>
        </div>
    </div>

    <script>
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const messageDiv = document.getElementById('message');
        const debugDiv = document.getElementById('debug');
        const switchBtn = document.getElementById('switch-btn');
        const startOverlay = document.getElementById('start-overlay');

        // ì˜¤ë””ì˜¤ ê°ì²´
        const successAudio = new Audio('success.mp3');
        successAudio.loop = true; 
        const pullingAudio = new Audio('pulling.mp3'); 
        
        let isSuccessPlaying = false;
        let isFrontCamera = true;
        let currentStream = null;
        let pose = null;
        let isRunning = false;

        // ë¡œì§ ë³€ìˆ˜
        let prevHeightDiff = 0; // (ì–´ê¹¨ Y - íŒ”ê¿ˆì¹˜ Y)
        let lastPullTime = 0;

        function toPixel(landmark, width, height) {
            return { x: landmark.x * width, y: landmark.y * height };
        }

        function calculateAngle(a, b, c) {
            const radians = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x);
            let angle = Math.abs(radians * 180.0 / Math.PI);
            if (angle > 180.0) angle = 360 - angle;
            return angle;
        }
        function calculateHorizontalDeviation(a, b) {
            const dy = b.y - a.y;
            const dx = b.x - a.x;
            let angle = Math.abs(Math.atan2(dy, dx) * 180.0 / Math.PI);
            if (angle > 90) angle = Math.abs(180 - angle);
            return angle;
        }

        // ì„  ê·¸ë¦¬ê¸° í—¬í¼
        function drawLine(ctx, p1, p2, color, width) {
            if (!p1 || !p2) return;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.strokeStyle = color;
            ctx.lineWidth = width;
            ctx.stroke();
        }

        // ìŠ¤í‹±ë§¨ ê·¸ë¦¬ê¸° í•¨ìˆ˜ (ActiveArm: ì›€ì§ì´ëŠ” íŒ”, isRising: ìƒìŠ¹ì¤‘ ì—¬ë¶€)
        function drawStickFigure(ctx, p, mainColor, activeArm, isRising) {
            const lineWidth = 6;
            
            // ì¼ë°˜ ìƒ‰ìƒ
            let leftArmColor = mainColor;
            let rightArmColor = mainColor;

            // ìƒìŠ¹ ì¤‘(ë‹¹ê¸¸ ë•Œ) êµ½íŒ íŒ”ë§Œ ë…¸ë€ìƒ‰ìœ¼ë¡œ ë³€ê²½
            if (isRising) {
                if (activeArm === 1) leftArmColor = "#FFFF00"; // ì™¼íŒ” ë…¸ë‘
                if (activeArm === 2) rightArmColor = "#FFFF00"; // ì˜¤ë¥¸íŒ” ë…¸ë‘
            }

            // ë¨¸ë¦¬ ì—°ê²°
            if (p[0] && p[11] && p[12]) {
                const midX = (p[11].x + p[12].x) / 2;
                const midY = (p[11].y + p[12].y) / 2;
                drawLine(ctx, {x: midX, y: midY}, p[0], mainColor, lineWidth);
            }

            // ëª¸í†µ (ì–´ê¹¨~ê³¨ë°˜)
            if (p[11] && p[12] && p[23] && p[24]) {
                drawLine(ctx, p[11], p[12], mainColor, lineWidth); // ì–´ê¹¨ì„ 
                drawLine(ctx, p[11], p[23], mainColor, lineWidth); // ì™¼ìª½ ëª¸í†µ
                drawLine(ctx, p[12], p[24], mainColor, lineWidth); // ì˜¤ë¥¸ìª½ ëª¸í†µ
                drawLine(ctx, p[23], p[24], mainColor, lineWidth); // ê³¨ë°˜ì„ 
            }

            // ì™¼íŒ”
            if (p[11] && p[13] && p[15]) {
                drawLine(ctx, p[11], p[13], leftArmColor, lineWidth);
                drawLine(ctx, p[13], p[15], leftArmColor, lineWidth);
            }
            // ì˜¤ë¥¸íŒ”
            if (p[12] && p[14] && p[16]) {
                drawLine(ctx, p[12], p[14], rightArmColor, lineWidth);
                drawLine(ctx, p[14], p[16], rightArmColor, lineWidth);
            }
        }

        function onResults(results) {
            if (!isRunning) return;

            const width = videoElement.videoWidth;
            const height = videoElement.videoHeight;
            canvasElement.width = width;
            canvasElement.height = height;

            canvasCtx.save();
            canvasCtx.clearRect(0, 0, width, height);

            if (results.poseLandmarks) {
                const rawLm = results.poseLandmarks;
                const p = {};
                // í•„ìš” ëœë“œë§ˆí¬: 0(ì½”), 11/12(ì–´ê¹¨), 13/14(íŒ”ê¿ˆì¹˜), 15/16(ì†ëª©), 23/24(ê³¨ë°˜)
                [0, 11,12,13,14,15,16,23,24].forEach(idx => {
                    if(rawLm[idx]) p[idx] = toPixel(rawLm[idx], width, height);
                });

                // === ë” ê¹Œë‹¤ë¡œì›Œì§„ ì„¤ì •ê°’ ===
                const ARM_HORIZON_LIMIT = 15;    // ìˆ˜í‰ ì˜¤ì°¨ (ì‘ì„ìˆ˜ë¡ ì—„ê²©)
                const ELBOW_STRAIGHT_MIN = 165;  // íŒ” í´ì§ ê°ë„ (í´ìˆ˜ë¡ ì—„ê²©, 180ì´ ì™„ì „ ì¼ì)

                let isSuccess = false;
                let failReason = "";
                let activeArm = 0; // 1:ì™¼íŒ” êµ½í˜(ë™ì‘íŒ”), 2:ì˜¤ë¥¸íŒ” êµ½í˜(ë™ì‘íŒ”)
                let isRising = false; // í˜„ì¬ ë‹¹ê¸°ëŠ” ì¤‘(ë…¸ë€ìƒ‰ í‘œì‹œìš©)

                // ìƒì²´ì™€ ê³¨ë°˜ê¹Œì§€ ë³´ì—¬ì•¼ í•¨
                if(p[11] && p[12] && p[13] && p[14] && p[15] && p[16] && p[23] && p[24]) {
                    
                    const lHorizon = calculateHorizontalDeviation(p[11], p[15]);
                    const rHorizon = calculateHorizontalDeviation(p[12], p[16]);
                    const lElbowAngle = calculateAngle(p[11], p[13], p[15]);
                    const rElbowAngle = calculateAngle(p[12], p[14], p[16]);

                    const isLeftStraight = (lHorizon < ARM_HORIZON_LIMIT) && (lElbowAngle > ELBOW_STRAIGHT_MIN);
                    const isRightStraight = (rHorizon < ARM_HORIZON_LIMIT) && (rElbowAngle > ELBOW_STRAIGHT_MIN);

                    // í•œìª½ì€ í´ê³ , í•œìª½ì€ êµ½í˜€ì•¼ ì„±ê³µ
                    if (isLeftStraight && !isRightStraight) {
                        isSuccess = true;
                        activeArm = 2; // ì˜¤ë¥¸íŒ”ì´ êµ½ì€ íŒ”
                    } else if (isRightStraight && !isLeftStraight) {
                        isSuccess = true;
                        activeArm = 1; // ì™¼íŒ”ì´ êµ½ì€ íŒ”
                    } else if (isLeftStraight && isRightStraight) {
                        failReason = "BEND ONE ARM";
                    } else {
                        failReason = "RAISE ONE ARM";
                    }
                }

                let color = isSuccess ? "#00FF00" : "#FF0000";

                if (isSuccess) {
                    messageDiv.innerText = "PULL ELBOW UP!";
                    messageDiv.style.borderColor = "#00FF00";
                    messageDiv.style.color = "#00FF00";
                    
                    if (!isSuccessPlaying) {
                        successAudio.play().catch(()=>{});
                        isSuccessPlaying = true;
                    }

                    // === ğŸ”¥ [ë¡œì§: ì–´ê¹¨-íŒ”ê¿ˆì¹˜ ë†’ì´ ì°¨ì´(ê¸°ìš¸ê¸°) ì¦ê°€ ê°ì§€] ğŸ”¥ ===
                    // HeightDiff = ì–´ê¹¨Y - íŒ”ê¿ˆì¹˜Y. 
                    // ê°’ì´ ì–‘ìˆ˜(+)ë©´ íŒ”ê¿ˆì¹˜ê°€ ì–´ê¹¨ë³´ë‹¤ ìœ„. ê°’ì´ í´ìˆ˜ë¡ ë” ìœ„.
                    
                    let currentHeightDiff = -999;
                    
                    if (activeArm === 1) { // ì™¼íŒ” ë™ì‘
                        currentHeightDiff = p[11].y - p[13].y;
                    } else if (activeArm === 2) { // ì˜¤ë¥¸íŒ” ë™ì‘
                        currentHeightDiff = p[12].y - p[14].y;
                    }

                    // íŒ”ê¿ˆì¹˜ê°€ ì–´ê¹¨ë³´ë‹¤ ë†’ê²Œ ìˆì–´ì•¼ ì‹œì‘ (ê°’ì´ 0ë³´ë‹¤ ì»¤ì•¼ í•¨)
                    if (currentHeightDiff > 0) {
                        
                        if (prevHeightDiff !== 0) {
                            // ë³€í™”ëŸ‰: í˜„ì¬ ë†’ì´ì°¨ - ì´ì „ ë†’ì´ì°¨
                            // ì–‘ìˆ˜ë©´ ë” ë†’ì´ ì˜¬ë¼ê°€ëŠ” ì¤‘ (ê¸°ìš¸ê¸° ì¦ê°€)
                            const delta = currentHeightDiff - prevHeightDiff;

                            // delta > 1.5 : ë…¸ì´ì¦ˆ í•„í„°ë§ (ì¡°ê¸ˆ ì›€ì§ì´ëŠ”ê±´ ë¬´ì‹œ)
                            if (delta > 1.5) {
                                isRising = true; // ì‹œê°ì  íš¨ê³¼ (ë…¸ë€ìƒ‰)
                                
                                const now = Date.now();
                                // ë¹¨ë¦¬ ì˜¬ë¦´ìˆ˜ë¡(deltaê°€ í´ìˆ˜ë¡) ë”œë ˆì´ ê°ì†Œ
                                let delay = Math.max(60, 500 - (delta * 25)); 

                                if (now - lastPullTime > delay) {
                                    const sound = pullingAudio.cloneNode();
                                    sound.volume = 1.0; 
                                    sound.play().catch(()=>{});
                                    lastPullTime = now;
                                }
                                debugDiv.innerText = `RISING: ${delta.toFixed(1)}`;
                            } else if (delta < -1.5) {
                                debugDiv.innerText = "LOWERING...";
                            } else {
                                debugDiv.innerText = "HOLDING...";
                            }
                        }
                    } else {
                        debugDiv.innerText = "ELBOW TOO LOW";
                    }

                    // í˜„ì¬ ë†’ì´ì°¨ ì €ì¥
                    prevHeightDiff = currentHeightDiff;

                } else {
                    messageDiv.innerText = failReason || "CHECK POSTURE";
                    messageDiv.style.borderColor = "#FF0000";
                    messageDiv.style.color = "#FFFFFF";
                    debugDiv.innerText = "INVALID";

                    if (isSuccessPlaying) {
                        successAudio.pause();
                        successAudio.currentTime = 0;
                        isSuccessPlaying = false;
                    }
                    prevHeightDiff = 0; 
                }

                // ìŠ¤í‹±ë§¨ ê·¸ë¦¬ê¸° (ActiveArmê³¼ Rising ìƒíƒœ ì „ë‹¬)
                drawStickFigure(canvasCtx, p, color, activeArm, isRising);
            }
            canvasCtx.restore();
        }

        async function setupCamera() {
            if (currentStream) currentStream.getTracks().forEach(track => track.stop());
            const constraints = {
                video: { width: { ideal: 1280 }, height: { ideal: 720 }, facingMode: isFrontCamera ? 'user' : 'environment' },
                audio: false
            };
            try {
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                currentStream = stream;
                videoElement.srcObject = stream;
                if (isFrontCamera) { videoElement.className = 'mirror'; canvasElement.className = 'mirror'; } 
                else { videoElement.className = 'normal'; canvasElement.className = 'normal'; }
                return new Promise((resolve) => { videoElement.onloadedmetadata = () => { resolve(videoElement); }; });
            } catch (err) { alert("Camera Error: " + err.message); }
        }

        async function renderFrame() {
            if (!videoElement.paused && !videoElement.ended) { await pose.send({image: videoElement}); }
            requestAnimationFrame(renderFrame);
        }

        async function initPose() {
            messageDiv.innerText = "LOADING...";
            pose = new Pose({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`});
            pose.setOptions({ modelComplexity: 1, smoothLandmarks: true, enableSegmentation: false, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            pose.onResults(onResults);
            await setupCamera();
            videoElement.play();
            renderFrame();
            messageDiv.innerText = "READY";
        }

        startOverlay.addEventListener('click', () => {
            startOverlay.style.display = 'none';
            isRunning = true;
            successAudio.play().then(()=>successAudio.pause()).catch(()=>{});
            pullingAudio.play().then(()=>pullingAudio.pause()).catch(()=>{});
            initPose();
        });

        switchBtn.addEventListener('click', async () => {
            isFrontCamera = !isFrontCamera;
            switchBtn.innerText = "LOADING...";
            await setupCamera();
            videoElement.play();
            switchBtn.innerText = "CAM SWITCH";
        });
    </script>
</body>
</html>
